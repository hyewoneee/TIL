# 도서리뷰 Real World HTTP 리얼 월드 HTTP
책을 읽고 정리하는 공간

# 목차

- [x] 1장. HTTP/1.0의 신택스: 기본이 되는 네 가지 요소
- [] 2장. HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면
- [] 3장. GO 언어를 이용한 HTTP/1.0 클라이언트 구현
- [] 4장. HTTP/1.1의 신택스: 고속화와 안전성을 추구한 확장
- [] 5장. HTTP/1.1의 시맨틱스: 확장되는 HTTP의 용도
- [] 6장. Go 언어를 이용한 HTTP1.1 클라이언트 구현
- [] 7장. HTTP/2의 신택스: 프로토콜 재정의
- [] 8장. HTTP.2의 시맨틱스: 새로운 활용 사례
- [] 9장. Go 언어를 이용한 HTTP/2, HTTP5 프로토콜 구현
- [] 10장. 보안: 브라우조를 보호하는 HTTP의 기능
- [] 11장. 클라이언트 시점에서 보는 RESTful API

# 1장. HTTP/1.0의 신택스: 기본이 되는 네 가지 요소

HTTP를 데이터의 상자로서 보면 통신 내용을 몇 가지 요소로 나눌 수 있다.

이 장에서는 다음 네 가지 기본 요소에 초점을 맞춰 소개한다.

- 메서드와 경로
- 헤더
- 바디
- 스테이터스 코드

HTTP를 다루는 도구로서 curl 커맨드 사용법도 소개한다.

curl 커맨들르 사용하면 원하는대로 서버에 요청을 보낼 수 있다.

### HTTP/0.9에서 1.0으로의 여정

HTTP/0.9는 매우 단순했지만 `'브라우저가 문서를 요청하면, 서버는 데이터를 반환한다'` 라는 웹의 기본 뼈대는 이미 이 시점에서 완성됐다.

그렇지만 이 프로토콜로는 할 수 없는 일이 많았다.

- 하나의 문서를 전송하는 기능밖에 없었다.
- 통신되는 모든 내용은 HTML 문서로 가정했으므로, 다운로드할 콘텐츠의 형식을 서버가 전달할 수단이 없었다.
- 클라이언트 쪽에서 검색 이외의 요청을 보낼 수 없었다.
- 새로운 문장을 전송하거나 갱신 또는 삭제할 수 없었다.

그 밖에도 요청이 올바른지 혹은 서버가 올바르게 응답했는지 아는 방법도 없었다.

1992년 버전에서는 단순버전(0.9 호환모드)과 전 기능(1.0과 거의 같다) 버전으로 두 종류의 요청 형식이 있었다.

요청의 변경된 점은 다음과 같다.

- 요청 시 메서드가 추가됐다(GET).
- 요청 시 HTTP 버전이 추가됐다(HTTP/1.0).
- 헤더가 추가됐다(Host, User-Agent, Accept).

### HTTP의 조상(1) 전자메일

HTTP에도 이 전자메일과 똑같은 형식의 헤더가 도입됐다.

헤더는 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령, 당부 등을 쓰는 장소다.

우선 클라이언트가 서버에 보내는 헤더다

**User-Agent**

클라이언트가 자신의 애플리케이션에 이름을 넣는곳.

curl 커맨드를 사용하면 curl/7.48.0과 같은 문자열이 들어가며

서버는 이곳의 이름을 보고 응답을 전환하기도 한다.

**Referer**

서버에서  참고하는 추가정보

클라이언트가 요청을 보낼 때 보고 있던 페이지의 URL을 보낸다.

페이지의 참조원을 서버가 참조하는데 이용한다.

**Authorization**

특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에서 전달한다.

RFC에서 몇 가지 표준 형식(Basic/Digest/Bearer)을 정했지만, 아마존 웹 서비스나 깃허브 API 등에서는 웹 서비스 자체 표기를 요구하기도 한다.

서버에서 클라이언트로 보낼 때 부여하는 헤더는 다음과 같은 것이 있다.

**Content-Type**

파일 종류를 지정

여기에는 MIME 타입이라는 식별자를 기술한다.

MIME 타입은 전자메일을 위해 만들어진 식별자다.

**Content-Length**

바디크기

**Content-Encoding**

압축이 이루어진 경우 압축 형식을 설명

**Date**

문서 날짜

### MIME 타입

MIME 타입은 파일의 종류를 구별하는 문자열로, 전자메일을 위해 만들어졌다.

파일 종류에 따라 브라우저 화면에 표시하거나 `'저장'` 대화창을 표시하는 기능을 제공하는데,

이때 파일 종류를 나타내는 식별자가 MIME 타입이다.

### Content-Type과 보안

브라우저 세계에서는 앞에서 소개한 것처럼 파일 종류를 특정할 때 Content-Type 헤더에서 지정된 MIME 타입을 사용 

인터넷 익스플로러는 인터넷 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하려고 한다.

이런 동작을 `콘텐트 스피닝(content sniffing)` 이라 한다.

이때 서버 설정이 잘못된 경우에도 제대로 표시되므로 얼핏 사용자에게 장점이 있는것처럼 여겨질 수 있지만, 원래 텍스트로만 표시돼야 하는 `text/plain` 파일인데도 HTML과 자바스크립트가 적혀있으면 브라우저가 파일을 실행해버리는 일도 있다.

뜻밖에 보안의 구멍이 될 수 있다.

서버에서는 다음과 같은 헤더를 전송해 브라우저가 추측하지 않도록 지시하는 것이 현재 주류의 방법이다.

`X-Content-Type-Option: nosniff`

### 전자메일과의 차이

헤더를 설명하면서 전자메일 포맷을 소개했다. HTTP와 비교해보자

- '헤더' + '본문' 구조는 같다.
- HTTP 요청에서는 선두에 '메서드+패스' 행이 추가된다.
- HTTP  응답에서는 선두에 스테이터스 코드가 추가된다.

### 메서드

 HTTP/1.0으로 통신할 때 전송되는 GET 부분은 메서드로 불린다.

- GET : 서버에 헤더와 콘텐츠 요청
- HEAD: 서버에 헤더만 요청
- POST: 새로운 문서 투고
- PUT: 이미 존재하는 URL의 문서를 갱신
- DELETE: 지정된 URL의 문서를 삭제

curl 커멘드로 메서드를 전송할 때는 `--request=` 메서드 혹은 그 단축형인 `-X` 메서드를 사용

	curl --http1.0 -X POST http://localhost:18888/greeting

### 스테이터스 코드

**100번대**

처리가 계속됨을 나타낸다

1xx계열은 특수한 용도로 사용

**200번대**

성공했을 때의 응답

**300번대**

서버에서 클라이언트로의 명령

오류가 아니라 정상 처리의 범주

리디렉트나 캐시 이용을 지시

**400번대**

클라이언트가 보낸 요청에 오류가 있다.

**500번대**

서버 내부에서 오류가 발생

### 리다이렉트

300번대 스테이터스의 일부는 서버가 브라우저에 대해 리디렉트하도록 지시하는 스테이터스 코드다.

300 이외의 경우는 **Location** 헤더를 사용해 리디렉트할 곳을 서버에서 클라이언트로 전달

영구적인지 일시적인지는 이동하는 이전 페이지가 이후에도 존재하는지로 분류한다.

**영구적**

새 도메인을 얻어 서버의 콘텐츠를 이동한 경우나 HTTP로 운영되던 페이지를 HTTPS로 전환한 경우에는 에전 페이지를 볼 일이 없다.

**일시적**

점검 기간에만 요청을 관리 화면으로 리디렉트할 경우 점검이 끝나면 복구해 다시 활성화할 것

**301/308**

요청된 페이지가 다른 장소로 이동했을 때 사용

영구적으로 이동

검색 엔진도 이 응답을 받으면 기존 페이지의 평가를 새로운 페이지로 게승한다.

구글은 검색 엔진에 페이지 이동을 전하는 수단으로써 **301**을 사용할 것을 권장

**302/307**

일시적인 이동

모바일 전용 사이트로 이동하거나 관리 페이지를 표시

**303**

요청된 페이지에 반환할 콘텐츠가 없거나 혹은 원래 반환할 페이지가 따로 있을 때, 그쪽으로 이동시키려고 사용한다.(로그인 페이지를 사용해 로그인한 후 원래 페이지로 이동하는 경우에 사용)

클라이언트는 **Location** 헤더 값을 보고, 다시 요청한다

재전송할 때는 헤더 등도 다시 보낸다.

curl 커맨드에 `-L` 을 부여하면, 응답이 300번대고 게다가 응답 헤더에 **Location** 헤더가 있으면 그 헤더에서 지정된 URL에 다시 요청을 보낸다.

또한 스테이터스 코드가 **301, 302, 303**이고 **GET** 이외의 메서드인 경우에는 **GET**으로 리디렉트를 다시 보낸다.

메서드를 바꿀수 없게 하는 옵션(—post301, —post302, —post303)도 있다.

기본으로 최대 50번 까지 리디렉트 한다.

리디렉트 횟수도 `--max-redirs` 옵션으로 지정할 수 있다.


### URL의 구조

URL은 아래와 같은 요소로 구성됨

**스키마://호스트명/경로**

- 스키마: https
- 호스트명: www.oreilly.co.jp
- 경로: index.shtml

URL 사양에 포함되는 모든 요소가 들어간 예제는 다음과 같은 형식

**스키마://사용자:패스워드@호스트명:포트/경로#프래그먼트?쿼리**

자주 보는 스키마로는 http외에 통신 경로가 암호화 되는 https, 메일러를 시작하는 mailot가 있다.

브라우저는 스키마를 보고 적절한 접속 방법을 선택해야한다.

실제로 통신하는 곳은 **호스트명**으로 지정된 서버이다.

포트는 아파트 등의 현관 우편함 같은 것이다.

주소(호스트명으로 찾아온 IP주소) 마다 65,535개의 포트가 있다.

같은 주소라도 포트가 다르면 독립적으로 복수의 서버를 운영해 서비스를 제공할 수 있다.

포트가 새얅되면 스키마별 기본 포트를 사용

HTTP : 80번 포트

HTTPS: 443번 포트

프래그먼트는 HTML에서는 페이지 내 링크의 앵커를 지정하는데 쓰인다.

쿼리는 검색 용어를 지정하거나 포시하고 싶은 웹페이지에 대해서 특정 파라미터를 부여하는데 사용 

URL은 주소를 지정하는 데 사용하지만, 동시에 `'사용자가 읽는 문장'`  이기도 하다.

### 바디

HTTP/0.9 사양에서는 요청에 데이터를 포함할 수 없었다.

응답은 파일 콘텐츠 자체였지만, 1.0에서는 요청과 응답 양쪽에 헤더가 포함돼 바디와 헤더를 분리할 필요가 있다. 또한 요청에도 콘텐츠를 포함할 수 있게 돼 새로운 역할이 늘어났다.

헤더 끝에 빈 줄을 넣으면 그 이후는 모두 바디가 된다.

이 구조는 전자메일과 똑같지만, 전송할 때 데이터를 저장하는 포맷이 두 종류로 용도에 맞게 구분할 필요가 있다.

    헤더1: 헤더 값 1
    헤더2: 헤더 값 2
    Content-Length: 바디의 바이트 수
    
    여기서부터 지정된 바이트 수만큼 바디가 포함된다.

한 번 응답할 때마다 한 파일만 반환하기 때문에 HTTP에서 응답의 바디는 단순하다.

속도를 위해 바디를 압축하는 경우가 있다.

이때는 Content-Encoding에서 지정된 압축 알고리즘으로 읽어 온 바디의 데이터를 전개할 필요가 있다.

이 경우 Content-Length는 압축 전 콘텐츠 길이가 아니라 압축 후 통신 데이터 크기다.

서버와 통신이 확립된 소켓에서 클라이언트가 읽는 바이트 수는 Content-Length에 적힌 데이터 길이로 압축되지 않았을 때와 다르지 않다.
---
# 2장. HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면

이 장에서는 curl 커맨드를 이용해 브라우저의 동작을 이해한다.

### 단순한 폼 전송(x-www-form-urlencoded)

curl 커맨드의 `-d` 옵션을 사용해 폼으로 전송할 데이터를 설정할 수 있다.

curl 커맨드는 `-d` 옵션이 지정되면 브라우저와 똑같이 헤더로 Content-Type:application/x-www-form-rulencoded를 설정

`-d` 옵션으로 보낼 경우 지정된 문자열을 그대로 연결

구분문자인 `&` 와 `=` 이 있어도 그대로 연결해버리므로, 읽는 쪾에서 바르게 원래 데이터 세트로 복원할 수 없다.

에를 들어 `Head First PHP & MYSQL` 이라는 서적명을 넣어보면, 어디서 구분해야 할 지 알기 어려워진다.

### 폼을 이용한 파일 전송

HTML의 폼에서는 옵션으로 멀티파트 폼 형식이라는 인코딩 타입을 선택할 수 있다.

보통 HTTP 응답은 한 번에 한 파일씩 반환하므로, 빈 줄을 찾아 그곳부터 `Content-Length` 로 지정된 바이트 수만큼 읽기만 하면 데이터를 통째로 가져올 수 있다.(파일의 경계를 신경쓸 필요가 없다)

멀티파트를 이용하는 경우는 한 번의 요청으로 복수의 파일을 전송할 수 있으므로 받는 쪽에서 파일을 나눠야한다.

`-d` 대신에 `-F` 를 사용하는 것만으로 curl 커맨드는 `enctype="multipart/form-data"`가 설정된 폼과 같은 형식으로 송신한다.

`-d` 와  `-F` 를 섞어 쓸 수는 없다. 

파일 전송은 `@` 를 붙여 파일 이름을 지정하면, 그 내용을 읽어와서 첨부한다.

아래와 같이 전송할 파일명과 파일 형식을 수동으로 설정할 수 있다.

type과 filename은 동시에 설정할 수 있다.

	# 파일 내용을 test.txt에서 최득. 파일명은 로컬 파일명과 같다. 형식도 자동 설정
	curl --http1.0 -F attachment-file@test.txt http://localhost:18888
	
	# 파일 내용을 test.txt에서 취득. 형식은 수동으로 지정.
	curl --http1.0 -F "attachment-file@test.txt;type=text/html" http://localhost.18888
	
	# 파일 내용을 test.txt에서 취득. 파일명은 지정한 파일명을 이ㅛㅇㅇ.
	curl --http1.0 -F "attachment-file@test.txt;filename-sample.txt"
	http://localhost:18888

### 폼을 이용한 리디렉트

1장의 1.6 리디렉트에서는 300번대 스테이터스 코드를 사용한 리디렉트를 소개했다.

하지만 이 방법에는 몇 가지 제한이 있다.

- 1장의 URL 항목에서 설명한 것처럼 URL에는 2천 자 이내라는 기준이 있어, GET의 쿼리로 보낼 수 있는 데이터양에 한계가 있다.
- 데이터가 URL에 포함되므로, 전송하는 내용이 액세스 로그 등에 남을 우려가 있따.

이런 분제를 피하고자 종종 이용되는 방법이 HTML의 폼을 이용한 리디렉트다.

서버로 부터는 리디렉트할 곳으로 보내고 싶은 데이터가 `<input type="hidden">` 태그로 기술된 HTML이 되돌아 온다. 

폼에서 보내는 곳이 리디렉트 할 곳이다.

브라우저가 이 HTML을 열면, 로드 직후 발생하는 이벤트로 폼을 전송하므로 즉시 리디렉트해 이동하게 된다.

이 방법의 장점은 인터넷 익스플로러에서도 데이터양에 제한이 없다는 점이다.

단점으로는 순간적으로 빈 페이지가 표시된다는 것과 전환 버튼이 표시되긴 하지만 자바스크립트가 비활성화되어 있으면 자동으로 전환되지 않는다는 점이다.

### 콘센트 니고시에이션

콘센트 니고시에이션은 통신 방법을 최적화하고자 하나의 요청 안에서 서버와 클라이언트가 서로  최고의 설정을 공유하는 시스템이다.

콘센트 니고시에이션에는 헤더를 이용한다.

	요청 헤더            응답                              니고시에이션 대상						
	Accept             Content-Type 헤더                 MIME 타입
	Accept-Language    Content-Language 헤더/html 태그    표시언어
	Accept-Charset     Content-Type 헤더                 문자의 문자셋
	Accept-Encoding    Content-Encoding 헤더             바디 압축

### 압축을 이용한 통신 속도 향상

콘텐츠 압축은 전송 속도 향상을 위한 것이다.

콘텐츠 내용에 따라 다르지만, 현재 일반적으로 사용되는 압축 알고리즘을 적용하면 텍스트 파일은 1/10 크기로 압축된다.

같은 기호가 반복해서 나오는 JSON 이라면 1/20 정도로 압축 할 수 있다.

통신에 걸리는 시간보다 압축과 해제가 짧은 시간에 이루어지므로, 압축을 함으로써 웹 페이지를 표시할 때 걸리는 전체적인 처리 시간을 줄일 수 있다.

콘텐츠 압축은 전송 속도 향상뿐만 아니라 이용 요금에도 영향을 미친다.

콘텐츠를 압축하면 비용부다도 줄어들고 모바일 단말은 전파 송수신에 전력을 많이 소비하므로, 전력 소비가 줄어드는 효과도 기대할 수 있다.

콘텐츠 압축 니고시에이션은 모두 HTTP의 헤더 안에서 완료한다.

우선 클라이언트가 수용 가능한 압축방식을 헤더에서 지정한다.

여기에서는 `deflate` 와 `gzip` 두가지를 지정햇다.

`Accept-Encoding: deflate, gzip`

curl 커맨드에서 `--compressed` 옵션을 지정하면 , `-H` 옵션으로 위 헤더를 기술한 것과 같다

	curl --http1.0 --compressed http://localhost:18888

서버는 전송받은 목록 중 지원하는 방식이 있으면, 응답할 때 그 방식으로 압축하거나 미리 압축된 콘텐츠를 반환한다.

서버가  `gzip` 을 지원하면, 조금 전에 받은 요청에 대한 응답으로 다음과 같은 헤더가 부여된다.

콘텐츠의 데이터양을 나타내는 `Content-Lenhth` 헤더는 압축된 파일 크기다.

`Content-Encoding: gzip` 

서버에서 클라이언트로 첫 번째 웹 페이지를 반환할 대 `Accept-Encoding`헤더를 부여하고, 그런 다음 클라이언트에서 무언가 업로드 할 때 `Content-Encoding` 을 부여한다.

지금의 고속화 방식과는 대조적으로 헤더가 이용된다. 

요청, 응답 양쪽에서 똑같이 헤어 구조가 이용되므로 이처럼 간단하게 구현할 수 있다.

### 쿠키

쿠키란 웹 사이트의 정보를 브라우저 쪽에 저장하는 작은 파일이다.

서버가 클라이언트(브라우저)에 `'이 파일 보관해줘'` 라고 쿠키 저장을 지시한다.

쿠키도 HTTP 헤더를 기반으로 구현됐다.

서버에서는 다음과 같이 응답 헤더를 보낸다.

	Set-Cookie: LAST_ACCESS_DATE=Jul/31/2016
	Set-Cookie: LAST_ACCESS_TIME=12:04

각각 `이름=값` 형식으로 회신했는데, 클라이언트는 이 값을 저장해 둔다.

다음번에 방문할 때는 다음과 같은 형식으로 보내자.

서버는 이 설정을 읽고,  클라이언트가 마지막으로 액세스한 시간을 알 수 있다.

	Cookie: LAST_ACCESS_DATE=Jul/31/2016
	Cookie: LAST_ACCESS_TIME=12:04

브라우저에서도 자바스크립트로 쿠키를 읽어내거나 서버에 보낼 때 쿠키를 설정할 수 있다.

개발자 도구를 열고 `document.cookie` 속성을 보면 쿠키가 문자열 형식으로 들어있는 것을 알 수 있다.

쿠키는 헤더를 바탕으로 만들어졌으므로 curl 커맨드를 사용할 때도 헤더로서 받은 내용을  `Cookie`에 넣고 재전송함으로써 실현할 수 있지만,

쿠키를 위한 전용 옵션도 있다.

`-c/--cookie-jar` 옵션으로 지정한 파일에 수신한 쿠키를 지정하고

`-b/--cookie` 옵션으로 지정한 파일에서 쿠키를 읽어와 전송한다.

브라우저처럼 동시에 송수신하려면 둘 다 지정해야한다.

`-b/--cookie` 옵션은 파일에서 읽기만 하는 게 아니라 개별 항목을 추가할 때도 사용할 수 있다.

	curl --http1.0 -c cookie.txt -b cookie.txt -b "name=value"
	http://example.com/helloworld

### 쿠키의 잘못된 사용법

쿠키는 편리한 기능이지만, 몇 가지 제약이 있어 적절하지 않은 사용법이 있다.

우선 영속성 문제

쿠키는 어떤 상황에서도 확실하게 저장되는 것은 아니다.

비밀모드 혹은 브라우저의 보안 설정에 따라 세션이 끝나면 초기화 되거나 쿠키를 보관하라는 서버의 지시를 무시하기도 한다.

서버가 쿠키를 데이터베이스 대신으로 쓸 수 는 없다.

쿠키가 초기화 되면 저장된 데이터는 사라지기 때문에 사라지더라도 문제가 없는 정보나 서버 정보로 복원할 수 있는 자료를 저장하는 용도에 적합하다.

또한 용량문제도 있다.

쿠키의 최대 크기는 4킬로바이트 사양으로 정해져 있어 더 보낼 수 는 없다.

쿠니는 헤더로서 항상 통신에 부가되므로 통신량이 늘어나는데, 통신량 증가는 요청과 응답 속도 모두에 영향을 미친다.

제한된 용량과 통신량 증가는 데이터베이스로 사용하는데 제약이 된다.

보안문제

`secure` 속성을 부여하면 HTTPS 프로토콜로 암호화된 통신에서만 쿠키가 전송되지만,

HTTP 통신에서는 쿠키가 평문으로 전송된다.

매 요청 시 쿠키가 송수신되는데, 보여선 안되는 정보등이 포함되면 노출될 위험성이 있다.

암호화된다고해도 사용자가 자유롭게 접근할 수 있는 것도 문제이다.

원리상 사용자가 쿠키를 수정할수도 있으므로, 시스템에서 필요한 정보가 수정되면 오작동으로 이어지는 민감한 정보를 넣는 것도 적합하지 않다. 

정보를 넣을 때는 서명이나 암호화처리가 필요하다.

기본적으로는 인증 정보나 사라져도 문제가 없는 정보만 쿠키에 넣는 편이 좋다.


