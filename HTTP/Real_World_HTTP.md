# 도서리뷰 Real World HTTP 리얼 월드 HTTP
책을 읽고 정리하는 공간

# 목차

- [] 1장. HTTP/1.0의 신택스: 기본이 되는 네 가지 요소
- [] 2장. HTTP/1.0의 시맨틱스: 브라우저 기본 기능의 이면
- [] 3장. GO 언어를 이용한 HTTP/1.0 클라이언트 구현
- [] 4장. HTTP/1.1의 신택스: 고속화와 안전성을 추구한 확장
- [] 5장. HTTP/1.1의 시맨틱스: 확장되는 HTTP의 용도
- [] 6장. Go 언어를 이용한 HTTP1.1 클라이언트 구현
- [] 7장. HTTP/2의 신택스: 프로토콜 재정의
- [] 8장. HTTP.2의 시맨틱스: 새로운 활용 사례
- [] 9장. Go 언어를 이용한 HTTP/2, HTTP5 프로토콜 구현
- [] 10장. 보안: 브라우조를 보호하는 HTTP의 기능
- [] 11장. 클라이언트 시점에서 보는 RESTful API

# 1장. HTTP/1.0의 신택스: 기본이 되는 네 가지 요소

HTTP를 데이터의 상자로서 보면 통신 내용을 몇 가지 요소로 나눌 수 있다.

이 장에서는 다음 네 가지 기본 요소에 초점을 맞춰 소개한다.

- 메서드와 경로
- 헤더
- 바디
- 스테이터스 코드

HTTP를 다루는 도구로서 curl 커맨드 사용법도 소개한다.

curl 커맨들르 사용하면 원하는대로 서버에 요청을 보낼 수 있다.

### HTTP/0.9에서 1.0으로의 여정

HTTP/0.9는 매우 단순했지만 `'브라우저가 문서를 요청하면, 서버는 데이터를 반환한다'` 라는 웹의 기본 뼈대는 이미 이 시점에서 완성됐다.

그렇지만 이 프로토콜로는 할 수 없는 일이 많았다.

- 하나의 문서를 전송하는 기능밖에 없었다.
- 통신되는 모든 내용은 HTML 문서로 가정했으므로, 다운로드할 콘텐츠의 형식을 서버가 전달할 수단이 없었다.
- 클라이언트 쪽에서 검색 이외의 요청을 보낼 수 없었다.
- 새로운 문장을 전송하거나 갱신 또는 삭제할 수 없었다.

그 밖에도 요청이 올바른지 혹은 서버가 올바르게 응답했는지 아는 방법도 없었다.

1992년 버전에서는 단순버전(0.9 호환모드)과 전 기능(1.0과 거의 같다) 버전으로 두 종류의 요청 형식이 있었다.

요청의 변경된 점은 다음과 같다.

- 요청 시 메서드가 추가됐다(GET).
- 요청 시 HTTP 버전이 추가됐다(HTTP/1.0).
- 헤더가 추가됐다(Host, User-Agent, Accept).

### HTTP의 조상(1) 전자메일

HTTP에도 이 전자메일과 똑같은 형식의 헤더가 도입됐다.

헤더는 서버와 클라이언트 사이에 필요한 추가 정보, 지시나 명령, 당부 등을 쓰는 장소다.

우선 클라이언트가 서버에 보내는 헤더다

**User-Agent**

클라이언트가 자신의 애플리케이션에 이름을 넣는곳.

curl 커맨드를 사용하면 curl/7.48.0과 같은 문자열이 들어가며

서버는 이곳의 이름을 보고 응답을 전환하기도 한다.

**Referer**

서버에서  참고하는 추가정보

클라이언트가 요청을 보낼 때 보고 있던 페이지의 URL을 보낸다.

페이지의 참조원을 서버가 참조하는데 이용한다.

**Authorization**

특별한 클라이언트에만 통신을 허가할 때 인증 정보를 서버에서 전달한다.

RFC에서 몇 가지 표준 형식(Basic/Digest/Bearer)을 정했지만, 아마존 웹 서비스나 깃허브 API 등에서는 웹 서비스 자체 표기를 요구하기도 한다.

서버에서 클라이언트로 보낼 때 부여하는 헤더는 다음과 같은 것이 있다.

**Content-Type**

파일 종류를 지정

여기에는 MIME 타입이라는 식별자를 기술한다.

MIME 타입은 전자메일을 위해 만들어진 식별자다.

**Content-Length**

바디크기

**Content-Encoding**

압축이 이루어진 경우 압축 형식을 설명

**Date**

문서 날짜

### MIME 타입

MIME 타입은 파일의 종류를 구별하는 문자열로, 전자메일을 위해 만들어졌다.

파일 종류에 따라 브라우저 화면에 표시하거나 `'저장'` 대화창을 표시하는 기능을 제공하는데,

이때 파일 종류를 나타내는 식별자가 MIME 타입이다.

### Content-Type과 보안

브라우저 세계에서는 앞에서 소개한 것처럼 파일 종류를 특정할 때 Content-Type 헤더에서 지정된 MIME 타입을 사용 

인터넷 익스플로러는 인터넷 옵션에 따라 MIME 타입이 아닌 내용을 보고 파일 형식을 추측하려고 한다.

이런 동작을 `콘텐트 스피닝(content sniffing)` 이라 한다.

이때 서버 설정이 잘못된 경우에도 제대로 표시되므로 얼핏 사용자에게 장점이 있는것처럼 여겨질 수 있지만, 원래 텍스트로만 표시돼야 하는 `text/plain` 파일인데도 HTML과 자바스크립트가 적혀있으면 브라우저가 파일을 실행해버리는 일도 있다.

뜻밖에 보안의 구멍이 될 수 있다.

서버에서는 다음과 같은 헤더를 전송해 브라우저가 추측하지 않도록 지시하는 것이 현재 주류의 방법이다.

`X-Content-Type-Option: nosniff`

### 전자메일과의 차이

헤더를 설명하면서 전자메일 포맷을 소개했다. HTTP와 비교해보자

- '헤더' + '본문' 구조는 같다.
- HTTP 요청에서는 선두에 '메서드+패스' 행이 추가된다.
- HTTP  응답에서는 선두에 스테이터스 코드가 추가된다.

### 메서드

 HTTP/1.0으로 통신할 때 전송되는 GET 부분은 메서드로 불린다.

- GET : 서버에 헤더와 콘텐츠 요청
- HEAD: 서버에 헤더만 요청
- POST: 새로운 문서 투고
- PUT: 이미 존재하는 URL의 문서를 갱신
- DELETE: 지정된 URL의 문서를 삭제

curl 커멘드로 메서드를 전송할 때는 `--request=` 메서드 혹은 그 단축형인 `-X` 메서드를 사용

	curl --http1.0 -X POST http://localhost:18888/greeting

### 스테이터스 코드

**100번대**

처리가 계속됨을 나타낸다

1xx계열은 특수한 용도로 사용

**200번대**

성공했을 때의 응답

**300번대**

서버에서 클라이언트로의 명령

오류가 아니라 정상 처리의 범주

리디렉트나 캐시 이용을 지시

**400번대**

클라이언트가 보낸 요청에 오류가 있다.

**500번대**

서버 내부에서 오류가 발생

### 리다이렉트

300번대 스테이터스의 일부는 서버가 브라우저에 대해 리디렉트하도록 지시하는 스테이터스 코드다.

300 이외의 경우는 **Location** 헤더를 사용해 리디렉트할 곳을 서버에서 클라이언트로 전달

영구적인지 일시적인지는 이동하는 이전 페이지가 이후에도 존재하는지로 분류한다.

**영구적**

새 도메인을 얻어 서버의 콘텐츠를 이동한 경우나 HTTP로 운영되던 페이지를 HTTPS로 전환한 경우에는 에전 페이지를 볼 일이 없다.

**일시적**

점검 기간에만 요청을 관리 화면으로 리디렉트할 경우 점검이 끝나면 복구해 다시 활성화할 것

**301/308**

요청된 페이지가 다른 장소로 이동했을 때 사용

영구적으로 이동

검색 엔진도 이 응답을 받으면 기존 페이지의 평가를 새로운 페이지로 게승한다.

구글은 검색 엔진에 페이지 이동을 전하는 수단으로써 **301**을 사용할 것을 권장

**302/307**

일시적인 이동

모바일 전용 사이트로 이동하거나 관리 페이지를 표시

**303**

요청된 페이지에 반환할 콘텐츠가 없거나 혹은 원래 반환할 페이지가 따로 있을 때, 그쪽으로 이동시키려고 사용한다.(로그인 페이지를 사용해 로그인한 후 원래 페이지로 이동하는 경우에 사용)

클라이언트는 **Location** 헤더 값을 보고, 다시 요청한다

재전송할 때는 헤더 등도 다시 보낸다.

curl 커맨드에 `-L` 을 부여하면, 응답이 300번대고 게다가 응답 헤더에 **Location** 헤더가 있으면 그 헤더에서 지정된 URL에 다시 요청을 보낸다.

또한 스테이터스 코드가 **301, 302, 303**이고 **GET** 이외의 메서드인 경우에는 **GET**으로 리디렉트를 다시 보낸다.

메서드를 바꿀수 없게 하는 옵션(—post301, —post302, —post303)도 있다.

기본으로 최대 50번 까지 리디렉트 한다.

리디렉트 횟수도 `--max-redirs` 옵션으로 지정할 수 있다.



